var documenterSearchIndex = {"docs":
[{"location":"model_formulation/nondimensionalization/#Nondimensionalization","page":"Nondimensionalization","title":"Nondimensionalization","text":"To isolate role of the aspect ratio, the nuPGCM ultimately solves the nondimensional PG equations, which we will derive here. We scale all spatial coordinates by the natural length scale of the domain L (e.g., the width of the basin) and all velocities by the same scale:\n\nx = L ndx quad y = L ndy quad z = L ndz quad mathrmand quad u = U ndu quad v = U ndv quad w = U ndw\n\nAlthough the code supports arbitrary initial conditions, we typically initialize all simulations with flat isopycnals aligned with gravity and constant stratification N^2 such that partial_z b = N^2 at t = 0. A natural scaling for buoyancy, therefore, would be b sim N^2 H_0 for some depth scale of the ocean H_0. Unlike in quasi-geostrophic theory, however, the PG equations do not explicitly impose a background stratification so that, in general, a representative scale for N^2 in the abyssal ocean will depend on the context of the problem. We additionally define characteristic scales for the Coriolis parameter and mixing coefficients:\n\nf sim f_0 quad nu sim nu_0 quad kappa sim kappa_0\n\nFinally, we assume that the pressure gradient term in the momentum equation scales with the Coriolis term, that the buoyancy also scales with the pressure scale divided by H_0 from hydrostatic balance, and that time scales advectively:\n\np sim f U L quad b sim fracf U LH_0 = N^2 H_0 quad t sim fracLU\n\nApplying these scales yields the following nondimensional PG equations:\n\nbeginaligned\n    ndf vecz times ndvecu = -ndnabla ndp + alpha^-1 ndb vecz + alpha^2 varepsilon^2 ndnabla cdot left( 2 ndnu ndsigma(ndvecu) right) hphantomfrac12\n    ndnabla cdot ndvecu = 0 hphantomfrac12\n    muvarrho left( pderndbndt + ndvecu cdot ndnablandb right) = alpha^2 varepsilon^2 ndnabla cdot left( ndkappa ndnabla ndb right)\nendaligned\n\nwhere alpha = H_0  L is the aspect ratio, varepsilon^2 = nu_0  f_0 H_0^2 is the Ekman number, varrho = N^2 H_0^2  f_0^2 L^2 is the Burger number, and mu = nu_0kappa_0 is the turbulent Prandtl number.\n\nFigure here?\n\nWith all three spatial coordinates scaled by L, the effect of the aspect ratio alpha on the dynamics is made explicit and the domain mathcalD itself must have an aspect ratio of alpha, i.e., -alpha le z le 0 (figure?). This scaling guarantees that the viscous friction term in the momentum equation is spatially isotropic, a desirable property for computing numerical solutions. More importantly, for alpha  0 hydrostatic balance is not exactly required, as can be seen by dotting the momentum equation with vecz:\n\npderndpndz = alpha^-1 ndb + alpha^2 varepsilon^2 ndnabla cdot left( 2 ndnu ndsigma(ndvecu) right) cdot vecz\n\nFor the ocean, typical order-of-magnitude length scales are H approx 10^3 m and L approx 10^6 m, implying alpha approx 10^-3. Hence, the small aspect ratio assumption is often made, eliminating the diffusion term on the RHS. While standard finite element techniques may be used to solve the Stokes problem with rotation, they become brittle under this approximation (e.g., [1]). To leverage established methods, we will therefore keep alpha larger than zero but small enough to capture the qualitative dynamics of the ocean. A similar approach was taken by [2] for a PG model with Rayleigh drag.","category":"section"},{"location":"model_formulation/nondimensionalization/#Boundary-conditions","page":"Nondimensionalization","title":"Boundary conditions","text":"Now let's work out how the boundary conditions must change under this particular nondimensionalization. Of course, the no-slip and no-normal-flow conditions at the bottom still imply ndvecu = 0 at ndz = -ndH. Since the buoyancy flux and wind stress boundary conditions involve vertical derivatives, though, we must take some care to ensure that they scale properly in the limit as alpha to 0. ","category":"section"},{"location":"model_formulation/nondimensionalization/#Surface-wind-stress","page":"Nondimensionalization","title":"Surface wind stress","text":"To illustrate this point, it helps to think about the net meridional transport psi, defined such that\n\n-pderpsiz = v quad textand quad pderpsix = w\n\nRecall that the velocity scale U = N^2 H_0^2  f_0 L. As with buoyancy, we want psi to scale like U H_0 (not U L), so we have\n\n-alpha pderndpsindz = ndv\n\nAs alpha to 0, the vertical derivative terms in the x-momentum equation should dominate such that\n\n-ndf ndv = -pderndpndx + alpha^2 varepsilon^2 pderndz left( ndnu pderndundz right)\n\nIntegrating in z, this gives\n\n-prettyintndz0ndfndvndz = -alpha ndf ndpsi sim alpha^2 varepsilon^2 ndnu pderndundz Big_ndz = 0\n\nneglecting the pressure gradient term and shear in the interior. Here's where the limit comes in: as alpha to 0, we want this interior transport to be equal to the wind-driven circulation, i.e., ndpsi sim -ndtau^xndf. For this to be true, we must have\n\nalpha^2 varepsilon^2 ndnu pderndundz = alpha ndtau^x quad textat quad ndz = 0\n\nor, more generally,\n\nboxedalpha^2 varepsilon^2 ndnu pderndvecu_perpndz = alpha ndvectau quad textat quad ndz = 0","category":"section"},{"location":"model_formulation/nondimensionalization/#Surface-buoyancy-flux","page":"Nondimensionalization","title":"Surface buoyancy flux","text":"What about the surface buoyancy flux condition? Here we want to ensure that the column-average buoyancy tendency remains fixed as alpha to 0. Integrating the buoyancy equation with advection neglected and diffusion only in the vertical, we have\n\nfrac1alpha prettyint-alpha0pderndbndtndz = fracalpha varepsilon^2mu varrho ndkappapderndbndz Big_ndz = 0 equiv ndmathcalF\n\nassuming partial_ndz ndb = 0 at the bottom. We therefore define our nondimensional surface buoyancy flux boundary condition as \n\nboxedfracalpha^2 varepsilon^2mu varrho ndkappapderndbndz = alpha ndmathcalF quad textat quad ndz = 0","category":"section"},{"location":"model_formulation/nondimensionalization/#Scales-and-parameter-values","page":"Nondimensionalization","title":"Scales and parameter values","text":"The parameters varepsilon, mu, and varrho are free to be chosen to match the physical context. The Coriolis parameter for Earth is about f_0 approx 10^-4 s^-1 and the stratification in the deep ocean is around N approx 10^-3 s^-1, yielding a Burger number of varrho approx 10^-4. Over rough topography, one might expect strong turbulence associated with a turbulent diffusivity on the order of kappa_0 approx 10^-3 m^2 s^-1 (e.g., [3]). The magnitude of the turbulent viscosity depends on whether or not a parameterization of eddies is considered. Without eddies, it is reasonable to assume that, for weakly stratified abyssal waters, small-scale mixing of buoyancy would occur on similar scales to the mixing of momentum, implying that nu_0 sim kappa_0, or mu sim 1 (e.g., [4]). An Eliassen–Palm flux equivalent to an eddy diffusivity of K approx 10^3 m^2 s^-1 [5], however, would require an enhanced viscosity of nu_0 approx 10 m^2 s^-1, or mu approx 10^4. In the first case, where nu_0 approx 10^-3 m^2 s^-1, the Ekman number varepsilon is on the order of 10^-3. In the eddy-parameterizing case of nu_0 approx 10 m^2 s^-1, on the other hand, it is enhanced to varepsilon approx 10^-1. Given that the nondimensional bottom Ekman layer thickness deltaL = sqrt2 nu_0  (f_0 L^2) = sqrt2  alpha varepsilon, these differences are crucial in setting the minimum resolution required for the simulation.\n\nFor the surface wind stress boundary condition, we have\n\nfracnu_0 UL ndnu pderndundz = fractau_0rho_0 ndtau\n\nTo be consistent with the boundary condition derived above, this implies that the wind stress scale should be\n\ntau_0 = fracrho_0alpha varepsilon^2 fracnu_0 N^2 H_0^2f_0 L^2 = fracrho_0 N^2 H_0^3L approx 1 text N m^-2\n\nusing the scales chosen above and a reference density of rho_0 = 10^3 kg m^-3. This means that a dimensional wind stress of 0.1 N m^-2 would translate to a nondimensional value of ndtau = 01.\n\nFor the surface buoyancy flux, we have\n\nfrackappa_0 N^2 H_0L ndkappa pderndbndz = mathcalF_0 ndmathcalF\n\nwhich, to be consistent with the for derived above, implies\n\nmathcalF_0 = fracmu varrhoalpha varepsilon^2 frackappa_0 N^2 H_0L = fracN^4 H_0^4f_0 L^2 approx 10^-8 text m^2 text s^-3\n\nusing the scales above. This means that a typical surface buoyancy flux of about 0.01 mm^2 s^-3 would translate to a nondimensional value of ndmathcalF = 1.","category":"section"},{"location":"references/#References","page":"References","title":"References","text":"F. Guillén-González and J. R. Rodríguez-Galván. Analysis of the hydrostatic Stokes problem and finite-element approximation in unstructured meshes. Numerische Mathematik 130, 225–256 (2015).\n\n\n\nR. Salmon. A simplified linear ocean circulation theory. Journal of Marine Research 44, 695–711 (1986).\n\n\n\nA. F. Waterhouse, J. A. MacKinnon, J. D. Nash, M. H. Alford, E. Kunze, H. L. Simmons, K. L. Polzin, L. C. St. Laurent, O. M. Sun, R. Pinkel, L. D. Talley, C. B. Whalen, T. N. Huussen, G. S. Carter, I. Fer, S. Waterman, A. C. Naveira Garabato, T. B. Sanford and C. M. Lee. Global patterns of diapycnal mixing from measurements of the turbulent dissipation rate. Journal of Physical Oceanography 44, 1854–1872 (2014).\n\n\n\nC. Caulfield. Layering, instabilities, and mixing in turbulent stratified flows. Annual Review of Fluid Mechanics 53, 113–145 (2021).\n\n\n\nP. R. Gent and J. C. Mcwilliams. Isopycnal mixing in ocean circulation models. Journal of Physical Oceanography 20, 150–155 (1990).\n\n\n\nT. J. Hughes. The Finite Element Method: Linear Static and Dynamic Finite Element Analysis (Dover Publications, Mineola, NY, 1987).\n\n\n\nH. C. Elman, D. J. Silvester and A. J. Wathen. Finite Elements and Fast Iterative Solvers: With Applications in Incompressible Fluid Dynamics. 2nd ed Edition, Numerical Mathematics and Scientific Computation (Oxford university press, Oxford, 2014).\n\n\n\nS. Danilov, G. Kivman and J. Schröter. A Finite-Element Ocean Model: Principles and Evaluation. Ocean Modelling 6, 125–150 (2004).\n\n\n\n","category":"section"},{"location":"literated/bowl_mixing/#Mixing-driven-circulation-in-a-bowl-shaped-basin","page":"Mixing in a bowl","title":"Mixing-driven circulation in a bowl-shaped basin","text":"This example illustrates the basic usage of the nuPGCM by simulating a mixing-driven circulation in a bowl-shaped basin. The typical workflow is:\n\nSet your Parameters and Forcings,\nLoad a Mesh,\nDefine the finite element Spaces, including all Dirichlet boundary conditions,\nBuild the linear systems for the inversion and evolution equations,\nConstruct a Model, and\nrun!\n\nWe will start by importing packages and setting the output directory for snapshot files.\n\nusing nuPGCM\nusing Printf\n\nset_out_dir!(joinpath(@__DIR__, \"\"))\n\n\"/home/runner/work/nuPGCM/nuPGCM/docs/src/literated//data\"\n\nYou can choose to run the model on either a CPU() or GPU(). When you run on the CPU, the model will try to factorize matrices if they are small enough. On the GPU (or for large problems on the CPU), the model uses iterative solvers. For simplicity here, let's just use a CPU.\n\narch = CPU()\n\nnuPGCM.CPU()","category":"section"},{"location":"literated/bowl_mixing/#Setting-Parameters-and-Forcings","page":"Mixing in a bowl","title":"Setting Parameters and Forcings","text":"Now we will define our parameters. See the Model Formulation docs for more details. Our bowl-shaped basin has a simple depth function of H(x y) = alpha (1 - x^2 - y^2).\n\nε = 2e-1   # Ekman number\nα = 1/2    # aspect ratio\nμϱ = 1     # Prandtl times Burger number\nN² = 1/α   # background stratification (if you want `b` to be a perturbation from N²z)\nΔt = 1e-3  # time step\nf₀ = 1.0\nβ = 0.5\nf(x) = f₀ + β*x[2]  # Coriolis parameter\nH(x) = α*(1 - x[1]^2 - x[2]^2)  # bathymetry\nparams = Parameters(ε, α, μϱ, N², Δt, f, H)\n\nnuPGCM.Parameters{Float64}\n├── ε  = 2.0e-01\n├── α  = 5.0e-01\n├── μϱ = 1.0e+00\n├── N² = 2.0e+00\n├── Δt = 1.0e-03\n├── f: f\n└── H: H\n\nNext, we define the forcings. For this simple example, we'll be applying bottom-enhanced mixing and no wind stress.\n\nν = 1  # viscosity (can be a function of x)\nκₕ(x) = 1e-2 + exp(-(x[3] + H(x))/(0.1*α)) # horizontal diffusivity\nκᵥ(x) = 1e-2 + exp(-(x[3] + H(x))/(0.1*α)) # vertical diffusivity\nτˣ(x) = 0  # zonal wind stress\nτʸ(x) = 0  # meridional wind stress\n\nτʸ (generic function with 1 method)\n\nYou can choose whether the surface buoyancy forcing is a flux boundary condition (with SurfaceFluxBC) or a dirichlet boundary condition (with SurfaceDirichletBC). Here we'll just set b = 0 at the surface.\n\nb_surface(x) = 0  # surface buoyancy boundary condition\nb_surface_bc = SurfaceDirichletBC(b_surface)\n# flux syntax:\n# b_flux_surface(x) = 0\n# b_surface_bc = SurfaceFluxBC(b_flux_surface)\n\nforcings = Forcings(ν, κₕ, κᵥ, τˣ, τʸ, b_surface_bc)\n\nnuPGCM.Forcings:\n├── ν: 1\n├── κₕ: κₕ\n├── κᵥ: κᵥ\n├── τˣ: τˣ\n├── τʸ: τʸ\n├── b_surface_bc: nuPGCM.SurfaceDirichletBC\n├── conv_param: off\n└── eddy_param: off\n\nNotice that forcings.conv_param and forcings.eddy_param are by default set to off. These (somewhat experimental) new features can be defined like so:\n\nconv_param = ConvectionParameterization(κᶜ=1e3, N²min=1e-3)\neddy_param = EddyParameterization(f=f, N²min=1e-2)\nForcings(ν, κₕ, κᵥ, τˣ, τʸ, b_surface_bc; conv_param, eddy_param)\n\nnuPGCM.Forcings:\n├── ν: 1\n├── κₕ: κₕ\n├── κᵥ: κᵥ\n├── τˣ: τˣ\n├── τʸ: τʸ\n├── b_surface_bc: nuPGCM.SurfaceDirichletBC\n├── conv_param: nuPGCM.ConvectionParameterization\n└── eddy_param: nuPGCM.EddyParameterization\n\nBut we'll leave them off here.","category":"section"},{"location":"literated/bowl_mixing/#Loading-a-Mesh","page":"Mixing in a bowl","title":"Loading a Mesh","text":"Now we load our mesh. For some examples of how to generate a mesh with Gmsh, see mesh_bowl2D.jl, mesh_bowl3D.jl, and others in the meshes/ directory of the repository.\n\nh = 8e-2\ndim = 3\nmesh_file = joinpath(@__DIR__, @sprintf(\"../../../meshes/bowl%dD_%e_%e.msh\", dim, h, α))  # for Literate.jl\n# mesh_file = joinpath(@__DIR__, @sprintf(\"../meshes/bowl%dD_%e_%e.msh\", dim, h, α))  # for running from `examples/`\nmesh = Mesh(mesh_file)\n\nnuPGCM.Mesh:\n├── model: UnstructuredDiscreteModel()\n├── Ω: BodyFittedTriangulation()\n├── dΩ: GenericMeasure()\n├── Γ: BoundaryTriangulation()\n└── dΓ: GenericMeasure()\n\nnote: Note\nYou may have noticed that the Mesh fields are Gridap types. Under the hood, nuPGCM uses Gridap to compute all the finite element integrals. When we define the Model later, the State will contain Gridap FEFunctions.","category":"section"},{"location":"literated/bowl_mixing/#Define-Spaces","page":"Mixing in a bowl","title":"Define Spaces","text":"As described on the Numerical Approach page, the nuPGCM uses finite elements under the hood to solve the PG equations. Now that we have an unstructured mesh set up, we just need to define our Dirichlet boundary conditions to  be able to set up our finite element spaces.\n\nIn Gmsh, one can assign labels to parts of the mesh by defining \"physical groups.\" For the mesh we're using here, there are three physical groups defined: the \"bottom\", \"coastline\", and \"surface\". To tell the nuPGCM where to apply Dirichlet boundary conditions, we define dictionaries for u, v, w, and b using these labels.\n\nu_diri = Dict(\"bottom\"=>0, \"coastline\"=>0)\nv_diri = Dict(\"bottom\"=>0, \"coastline\"=>0)\nw_diri = Dict(\"bottom\"=>0, \"coastline\"=>0, \"surface\"=>0)\nb_diri = Dict(\"surface\"=>b_surface, \"coastline\"=>b_surface)\n# b_diri = Dict()  # use this if b_surface_bc is a SurfaceFluxBC\nspaces = Spaces(mesh, u_diri, v_diri, w_diri, b_diri)\n\nnuPGCM.Spaces:\n├── X_trial: Gridap.MultiField.MultiFieldFESpace{Gridap.MultiField.ConsecutiveMultiFieldStyle, Gridap.FESpaces.UnConstrained, Vector{Float64}}\n├── X_test: Gridap.MultiField.MultiFieldFESpace{Gridap.MultiField.ConsecutiveMultiFieldStyle, Gridap.FESpaces.UnConstrained, Vector{Float64}}\n├── B_trial: Gridap.FESpaces.TrialFESpace{Gridap.FESpaces.UnconstrainedFESpace{Vector{Float64}, Gridap.FESpaces.CellConformity{Vector{Int8}}}}\n├── B_test: Gridap.FESpaces.UnconstrainedFESpace{Vector{Float64}, Gridap.FESpaces.CellConformity{Vector{Int8}}}\n└── b_diri: Gridap.FESpaces.SingleFieldFEFunction{Gridap.CellData.GenericCellField{Gridap.CellData.ReferenceDomain}}\n\nWe have enforced the u = v = w = 0 on the \"bottom\" and \"coastline\", w = 0 at the \"surface\", and b = 0 at the \"surface\" and on the \"coastline\". All other boundaries are treated \"naturally,\" i.e., the flux across them is zero.\n\nwarning: Be careful about defining your physical groups!\nMake sure that when you create your .msh files you carefully check that your physical groupd definitions properly account for every entity in the mesh! For some examples, see the meshes/ folder in the nuPGCM repository.\n\nOur mesh and spaces are then passed to the FEData constructor, which keeps track of all the finite element data needed to compute build our linear systems.\n\nfe_data = FEData(mesh, spaces)\n\nnuPGCM.FEData:\n├── mesh: nuPGCM.Mesh\n├── spaces: nuPGCM.Spaces\n└── dofs: nuPGCM.DoFHandler{Vector{Int64}, Int64} with (nu=10551, nv=10551, nw=8251, np=2042, nb=11211) DOFs\n\nBehind the scenes, this created a DoFHandler, which you can use to print out how many degrees of freedom the inversion system will have.\n\n@info \"Inversion DOFs: $(fe_data.dofs.nu + fe_data.dofs.nv + fe_data.dofs.nw + fe_data.dofs.np)\"\n\n[ Info: Inversion DOFs: 31395\n","category":"section"},{"location":"literated/bowl_mixing/#Build-linear-systems","page":"Mixing in a bowl","title":"Build linear systems","text":"We now have everything we need to build the linear systems that represent the discretized PG equations on this mesh. First, we build the inversion system alone, as it does not have a time-dependent piece:\n\ninversion_toolkit = InversionToolkit(arch, fe_data, params, forcings; atol=1e-6, rtol=1e-6)\n\nnuPGCM.InversionToolkit:\n├── B: 31395×11211 SparseArrays.SparseMatrixCSC{Float64, Int64} with 206931 stored entries\n├── b: 31395-element Vector{Float64}\n└── solver: nuPGCM.IterativeSolverToolkit\n\nThe atol and rtol kwargs are the absolute and relative tolerances, respectively, used when solving the system iteratively. Make them smaller if you want higher accuracy at the expense of more inversion iterations. Since we are on a CPU and our mesh is quite coarse in this example, however, the model will actually just do a direct solve, so these tolerances are unused.\n\nAt this point, we can already compute the flow field if we know what the buoyancy field is. To do this, just create a Model without an evolution piece, set the buoyancy field, and invert:\n\nmodel = Model(arch, params, forcings, fe_data, inversion_toolkit)\nset_b!(model, x -> 0.1*exp(-(x[3] + H(x))/(0.1*α)))\ninvert!(model)\nsave_state(model, \"$out_dir/data/state.jld2\")\nsave_vtk(model, ofile=\"$out_dir/data/state.vtu\")\n\n[ Info: Model state saved to '/home/runner/work/nuPGCM/nuPGCM/docs/src/literated//data/state.jld2'\n[ Info: VTK state saved to '/home/runner/work/nuPGCM/nuPGCM/docs/src/literated//data/state.vtu'\n\n\nHere we want to see how the flow and buoyancy evolve in time, however, so we need to build the evolution system.\n\nevolution_toolkit = EvolutionToolkit(arch, fe_data, params, forcings)\n\nnuPGCM.EvolutionToolkit:\n├── arch: nuPGCM.CPU()\n├── B_hdiff: 11211×11211 SparseArrays.SparseMatrixCSC{Float64, Int64} with 267151 stored entries\n├── b_hdiff: 11211-element Vector{Float64}\n├── B_vdiff: 11211×11211 SparseArrays.SparseMatrixCSC{Float64, Int64} with 267151 stored entries\n├── b_vdiff: 11211-element Vector{Float64}\n├── solver_adv: nuPGCM.IterativeSolverToolkit\n├── solver_hdiff: nuPGCM.IterativeSolverToolkit\n└── solver_vdiff: nuPGCM.IterativeSolverToolkit","category":"section"},{"location":"literated/bowl_mixing/#Construct-Model","page":"Mixing in a bowl","title":"Construct Model","text":"Now we put everything together in the Model type.\n\nmodel = Model(arch, params, forcings, fe_data, inversion_toolkit, evolution_toolkit)\n\nnuPGCM.Model:\n├── arch: nuPGCM.CPU()\n├── params: nuPGCM.Parameters{Float64}\n├── forcings: nuPGCM.Forcings\n├── fe_data: nuPGCM.FEData\n├── inversion: nuPGCM.InversionToolkit\n├── evolution: nuPGCM.EvolutionToolkit\n└── state: nuPGCM.State\n\nWe can set the intial condition to be whatever we want with set_b!(model, foo) where foo is a function of x. By default, the buoyancy is always set to 0 initially. Since we set N² to 1/α, this means that our buoyancy field starts out as x[3]/α―a constant stratification. If you had N² = 0, then you would need to do set_b!(model, x -> x[3]/α) to get the same effect. The benefit of having a nonzero background startification is that the inversion tends to be more accurate for smaller variations in buoyancy.\n\nTo start with, let's sync up the flow with whatever initial condition we chose and save a .vtu file.\n\ninvert!(model) # sync flow with initial condition\nsave_vtk(model, ofile=@sprintf(\"%s/data/state_%016d.vtu\", out_dir, 0))\n\n[ Info: VTK state saved to '/home/runner/work/nuPGCM/nuPGCM/docs/src/literated//data/state_0000000000000000.vtu'\n","category":"section"},{"location":"literated/bowl_mixing/#run!","page":"Mixing in a bowl","title":"run!","text":"Finally, it's time to run the model! run! just needs to know how many steps to take n_steps, how often to make save files n_save (default Inf), and how often to make plots n_plot (default Inf). If you want to turn advection off and only diffuse buoyancy, set advection=false. If you are starting from a save file, you can also set i_step to something other than 1.\n\nT = 0.1*μϱ/ε^2  # simulation time\nn_steps = Int(round(T / Δt))\nn_save = n_steps ÷ 100\nrun!(model; n_steps, n_save)\n\nnuPGCM.Model:\n├── arch: nuPGCM.CPU()\n├── params: nuPGCM.Parameters{Float64}\n├── forcings: nuPGCM.Forcings\n├── fe_data: nuPGCM.FEData\n├── inversion: nuPGCM.InversionToolkit\n├── evolution: nuPGCM.EvolutionToolkit\n└── state: nuPGCM.State\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"model_formulation/numerical_approach/#Numerical-Approach","page":"Numerical Approach","title":"Numerical Approach","text":"Here we'll describe the numerical scheme used in the nuPGCM to solve the nondimensional PG equations described previously. We discretize the domain using an unstructured mesh of tetrahedra, allowing considerable geometrical flexibility at the cost of requiring a more sophisticated numerical method than standard finite differences on a structured grid. The numerical solution satisfies the weak Galerkin form of the equations and lives in a specially chosen finite element space to guarantee stability. To obtain smooth solutions, we must artificially increase the aspect ratio alpha, introducing diffusion in the hydrostatic equation. The matrix equations for the PG inversion and evolution are solved separately using iterative solvers. We use Strang splitting to handle advection and diffusion as separate partial steps in the evolution equation.","category":"section"},{"location":"model_formulation/numerical_approach/#Weak-formulation","page":"Numerical Approach","title":"Weak formulation","text":"To derive the finite element formulation of the model equations, we first define the function spaces in which we would like our solutions to live. These spaces need not specify any Neumann conditions as those will be taken care of by boundary integrals in the weak formulation, as we will see below. The velocity, pressure, and buoyancy spaces are then:\n\nbeginaligned\n    mathcalU equiv Big vecu in H^1(mathcalD)^3  vecu = 0  textat  z = -H  textand  w = 0  textat  z = 0 Big\n    mathcalP equiv Big p in L^2(mathcalD)  int_mathcalD p  textdvecx = 0 Big\n   mathcalB equiv L^2(mathcalD) quad textor quad mathcalB equiv Big b in L^2(mathcalD)  b = b_0  textat  z = 0 Big\nendaligned\n\nrespectively, where the buoyancy space depends on whether a Dirichlet or Neumann condition is chosen at the surface. Here, H^1(mathcalD)^3 refers to the Sobolev space of all three-component vector functions that satisfy\n\nlVert vecu rVert_H^1^2 = int_mathcalD left( u^2 + v^2 + w^2 + nabla u^2 + nabla v^2 + nabla w^2 right)  textdvecx   infty\n\nand L^2(mathcalD) refers to the Lebesgue space of all functions that are square integrable, i.e.,\n\nlVert p rVert_L^2^2 = int_mathcalD p^2  textdvecx  infty\n\nWithout the integral constraint in mathcalP, the pressure may only be determined up to an additive constant.\n\nThe weak form of the PG inversion is obtained by dotting the inversion and continuity equations with test functions (vecv q) in mathcalU times mathcalP, integrating over the domain, and performing integration by parts on the divergence of the strain rate, yielding\n\nint_mathcalD left (f vecz times vecu) cdot vecv \n    + nabla p cdot vecv  \n    + (nabla cdot vecu) q \n    + 2 alpha^2 varepsilon^2 nu sigma(vecu) odot sigma(vecv) right textdvecx  \n= int_mathcalD alpha^-1 b vecz cdot vecv textdvecx \n    + alpha int_z = 0 vectau cdot vecv_perp textd vecx\n\nThis is known as a saddle-point problem (notice that the pressure p never multiplies its test function q). As we will see later, this limits the discrete spaces on which we may stably represent the solution. Following the same steps for the buoyancy equation, this time multiplying by a test function c in mathcalB, yields the weak formulation\n\nint_mathcalD left pderbt c + (vecu cdot nabla b) c + theta kappa nabla b cdot nabla c right textdvecx = alpha int_z=0 mathcalF c textdvecx\n\nwhere theta = alpha^2 varepsilon^2  mu varrho. In the Dirichlet boundary condition case, the last integral over z = 0 is removed.","category":"section"},{"location":"model_formulation/numerical_approach/#Finite-element-discretization","page":"Numerical Approach","title":"Finite element discretization","text":"(Image: 2D and 3D tetrahedral meshes) Meshes mathcalT_h of (a) two- and (b) three-dimensional basin domains and sketches of (c) triangular and (d) tetrahedral finite elements T_k in mathcalT_h. In the mixed finite element method described below, the pressure degrees of freedom mathbfp_i^k correspond to values on the vertices of each element while the velocity and buoyancy degrees of freedom mathbfu_i^k and mathbfb_i^k exist on both the vertices and midpoints. The superscripts indicate that these are the degrees of freedom on the local element T_k.\n\nTo solve the weak formulation above numerically, we tesselate the domain into a mesh mathcalT_h of finite pieces (or \"elements\") with characteristic length scale h. In two dimensional space, each element T_k in mathcalT_h is a triangle whereas in three dimensions we use tetrahedra. In general, the quality of the mesh can have a significant impact on the accuracy of the solution. We typically use meshes generated by Gmsh, although there are many other meshing software packages available.  In general, one now defines a subspace of the full solution space that can be spanned by a finite number of basis functions defined on the mesh, converting the continuous form of the weak formulation into a discrete problem. A simple and common choice for this subspace is the set of continuous, piecewise-polynomial functions of degree n over the elements, P_n(mathcalT_h). Denoting each node in the mesh by vecx_i, one can create a set of basis functions for this space varphi_i that satisfy\n\nvarphi_i(vecx_j) = delta_ij\n\nwhere delta_ij is the Kronecker delta. For the linear space P_1(mathcalT_h), the element vertices supply enough nodes to span the space (orange crosses in the figure above), but for higher-order spaces, more nodes are needed.\n\nSince our formulation of the PG inversion is equivalent to the Stokes problem with rotation, we can employ a standard mixed finite element scheme.  Although not all discrete subspaces are stable for saddle-point problems such as the PG inversion, if they satisfy the so-called LBB condition, a unique solution that depends continuously on the forcing exists [6, 7]. It is possible to choose a finite element basis that does not satisfy the LBB condition, but ad hoc stabilization schemes are necessary [8]. We instead choose the simple and accurate P_2–P_1 basis that is known to satisfy the LBB condition. In this basis, the velocities are quadratic while the pressure is linear, so that  the discrete subspaces defined over the mesh are\n\nmathcalU_h equiv P_2(mathcalT_h)^3 cap mathcalU quad mathrmand quad mathcalP_h equiv P_1(mathcalT_h) cap mathcalP\n\nThe degrees of freedom for the velocity components therefore exist on both the midpoints and vertices of the elements while those of the pressure are just on the vertices. The added degrees of freedom from using second-order elements increases the computational demand of the PG inversion, but, as we will see in the next section, the convergence rate is rapid enough that resolution constraints are not as high. While not needed for stability, we represent buoyancy with quadratic, rather than linear, polynomials to ensure high accuracy:\n\nmathcalB_h equiv P_2(mathcalT_h) cap mathcalB\n\nWith these discrete subspaces, we can assemble the matrices needed to compute the PG inversion and evolve buoyancy in time. If  vecvarphi_i ,  psi_i , and  varphi_i  are the sets of basis vectors for mathcalU_h, mathcalP_h, and mathcalB_h, respectively, then the solution to the weak formulation of the PG equations can be represented as linear combinations of these functions:\n\nvecu_h(vecx) = mathbfu_i cdot vecvarphi_i(vecx) quad p_h(vecx) = mathbfp_i psi_i(vecx) quad b_h(vecx) = mathbfb_i varphi_i(vecx)\n\nwith mathbfu, mathbfp, and mathbfb being the vectors of projection coefficients and summation is implied. Note that, because the underlying basis vectors are continuously defined over the entire domain, so are the solutions. This is in contrast to typical finite difference methods where the solution is only defined on the grid. Conveniently, because of the choice of nodal basis functions, the projection coefficients are equal to the values of these functions on the nodes of the mesh:\n\nvecu_h(vecx_i) = mathbfu_i quad p_h(vecx_i) = mathbfp_i quad b_h(vecx_i) = mathbfb_i\n\nGiven the buoyancy coefficients mathbfb, the coefficients for the velocity and pressure mathbfx = mathbfu mathbfp^T can be determined by solving the matrix equation\n\nhatmathbfK mathbfx = hatmathbfM mathbfb + mathbfs\n\nwhere hatmathbfK, hatmathbfM, and mathbfs are computed by integrating the weak formulation of the inversion for each basis function. For instance,\n\nhatmathbfM_ij = alpha^-1 int_mathcalD varphi_j vecz cdot vecvarphi_i textdvecx quad textand quad mathbfs_i = alpha int_z=0 vectau cdot vecvarphi_perp textdvecx\n\nWe use the Julia package Gridap.jl to automate this step. A high-resolution three-dimensional inversion can easily contain millions of tetrahedra, making a direct solve of this matrix equation impractical. Instead, we load hatmathbfK onto a GPU using CUDA.jl and solve the problem iteratively using Krylov.jl's implementation of the generalized minimum residual method (GMRES).\n\nFrom finite element theory [6, 7], the error in the so-called \"energy norm\" for the P_2–P_1 method scales as\n\nlVert vecu_h rVert_H^1 + lVert p - p_h rVert_L^2 sim O(h^2)\n\nwhere, again, h is the characteristic mesh resolution. We find that this is indeed the case for test inversions with the nuPGCM. We also find that, when isopycnals are relatively flat, this error scales roughly like O(alpha^-2varepsilon^-2). This follows from the fact that the BL scale is proportional to alpha varepsilon so that the effective resolution with respect to the BL h_mathrmeff sim h(alphavarepsilon). Since the error tends to be concentrated near the boundary for flat isopycnals, it is not a surprise that the energy norm scales like h_mathrmeff^2.\n\nWhile there is not a general theory for the scaling of the maximum error lVert vecu_h rVert_L^infty equiv sup_mathcalD vecu_h, its value is more interpretable than that of the energy norm. We find that, again for a test problem with flat isopycnals, the error empirically scales with h^3. This rapid convergence rate in the maximum pressure gradient error is promising for the accuracy of large-scale ocean circulation simulated by this model. Next, we will couple the inversion to the evolution equation to simulate time-dependent flow.","category":"section"},{"location":"model_formulation/numerical_approach/#Timestepping","page":"Numerical Approach","title":"Timestepping","text":"(Image: Flow chart of a single Strang-split timestep) Flow chart of a single Strang-split timestep from t^n to t^n+1 = t^n + Delta t in a simulation. \"Invert\" refers to solving the matrix equation for the PG inversion above. The half- and forward advection steps and the Delta t 2 diffusion steps are described below.\n\nOnce the solution is projected onto the discrete finite element space described above, the weak form of the buoyancy evolution becomes\n\nmathbfM pdermathbfbt + F(mathbfu mathbfb) + theta mathbfK mathbfb = mathbff\n\nwhere\n\nmathbfM_ij = int_mathcalD varphi_i varphi_j textdvecx quad mathrmand quad mathbfK_ij = int_mathcalD kappa nablavarphi_i cdot nablavarphi_j textdvecx\n\nare known as the \"mass\" and \"stiffness\" matrices in the finite element literature and the vector mathbff is due to the forcing terms on the right-hand side. The non-linear advection term takes the form (again summation implied),\n\nF(mathbfu mathbfb)_i = mathbfu_k mathbfb_j int_mathcalD (vecvarphi_k cdot nabla vecvarphi_j) varphi_i textdvecx\n\nwhich must be explicitly re-computed as the solution evolves. \n\nTo simplify the treatment of both advection and diffusion, we employ Strang splitting to handle each separately. Specifically, we split each timestep into (1) a half-step of diffusion, (2) a full-step of advection, and (3) a final half-step of diffusion (see schematic below). For advection, we use a second-order explicit Runge–Kutta step (also known as the midpoint method):\n\nbeginaligned\n    textStep 1 quad textSolve inversion system for  mathbfu^n  textgiven  mathbfb^n\n    textStep 2 quad mathbfb^n + frac12_* = mathbfb^n - fracDelta t2 mathbfM^-1 F(mathbfu_i^n mathbfb^n)\n    textStep 3 quad textSolve inversion system for  (mathbfu_i)^n+frac12_*  textgiven  mathbfb^n+frac12_*\n    textStep 4 quad mathbfb^n+1_* = mathbfb^n - Delta t mathbfM^-1 Fleft( (mathbfu_i)^n + frac12_* mathbfb^n+frac12_*right)\nendaligned\n\nwhere Delta t is the step size. The superscripts are a short-hand for mathbfb^n = mathbfb(t^n) where t^n = nDelta t with n = 0 1 2 ldots and the the subscript _* indicates that only an advection step has been performed. The matrix mathbfM^-1 is not computed explicitly, but instead the linear system is iteratively solved on a GPU using the conjugate gradient (CG) method. Using a left preconditioner of (textdiag  mathbfM)^-1, this approach is extremely efficient, typically converging to a reasonable tolerance in less than 10 iterations. Note that this second-order method requires two updates of the velocity field (steps 1 and 3). For the diffusion half-steps, we use the second-order accurate, semi-implicit Crank–Nicolson method:\n\nleft(mathbfM + theta fracDelta t4 mathbfK right) mathbfb^n+1 = left(mathbfM - theta fracDelta t4 mathbfK right) mathbfb^n+1_* + Delta t mathbff\n\nWe again solve this linear system using the CG method preconditioned by the inverse of the diagonal of the matrix on the left-hand side.\n\nA key advantage of solving the PG equations as opposed to the full Boussinesq system is that they filter out fast-timescale dynamics, allowing for large timesteps. For a typical global-scale simulation, a dimensional timestep of Delta t  (f_0 varrho) sim O(10 text days) is possible.  This timestep, which is orders of magnitude larger that that of most global ocean models, enables us to relatively cheaply simulate large-scale ocean dynamics over long timescales. ","category":"section"},{"location":"model_formulation/pg_equations/#PG-Equations","page":"The PG Equations","title":"PG Equations","text":"As discussed in the overview, we aim to describe the large-scale ocean circulation using the PG equations, which are derived from the Boussinesq equations by assuming large horizontal scales and small Rossby numbers. In index notation, the dimensional PG equations in Cartesian space (x y z) read\n\nbeginaligned\n    f vecz times vecu = -nabla p + b vecz + nabla cdot left( 2 nu sigma(vecu) right) hphantomfrac12\n    nabla cdot vecu = 0 hphantomfrac12\n    pderbt + vecu cdot nabla b = nabla cdot left( kappa nabla b right)\nendaligned\n\nwhere vecu = (u v w) is the velocity vector, p is the pressure, and b is the buoyancy. The first term in the momentum equation represents the Coriolis acceleration, with vecz = (0 0 1) being the unit vector in the vertical and f the Coriolis parameter. The buoyancy force acts only in the vertical. We parameterize turbulent mixing of buoyancy by a down-gradient flux proportional to the turbulent diffusivity kappa. The Eliassen–Palm fluxes parameterizing mixing due to eddies contribute a diffusion term in the momentum equations with eddy viscosity nu. To account for spatially varying nu, this friction term is written in terms of the rank-2 strain rate tensor sigma(vecu) = frac12 left left(nabla vecuright) + left(nabla vecuright)^T right or, in index notation,\n\nsigma(vecu)_ij = frac12 left( fracpartial u_ipartial x_j + fracpartial u_jpartial x_i right)\n\nFor constant nu, this term is equivalent to the regular Laplacian of vecu. We apply no-slip and no-normal flow conditions on at the bottom z = -H, and at the surface z = 0 we demand no normal flow and a stress set by the wind:\n\nbeginaligned\n    vecu = 0 quad mathrmat quad z = -H\n    w = 0 quad mathrmand quad nu pdervecu_perpz = vectau quad mathrmat quad z = 0\nendaligned\n\nwhere vecu_perp = (u v) and vectau = (tau^x tau^y) is the normal vector to the boundary. The buoyancy flux through the bottom is set to mathcalG (typically zero unless accounting for geothermal heating effects), and either the buoyancy or the buoyancy flux can be set at the surface:\n\nbeginaligned\n    kappa pderbz = mathcalG quad mathrmat quad z = -H\n    b = b_mathrmS quad mathrmor quad kappa pderbz = mathcalF quad mathrmat quad z = 0\nendaligned\n\nThese PG dynamics can be viewed separately as an evolution equation for buoyancy and an inversion statement for the flow.","category":"section"},{"location":"#\\nuPGCM","page":"Overview","title":"nuPGCM","text":"Interested in simulating the large-scale ocean circulation over long timescales?  Then the planetary geostrophic circulation model (nuPGCM) might be for you!  Some highlights:\n\nCapable of simulating arbitrary domains thanks to the finite elements formulation\nWritten in Julia \nRuns on a GPU","category":"section"},{"location":"#Installation","page":"Overview","title":"Installation","text":"If you don't have Julia installed already, download it here (currently, the package environment is built with Julia version 1.10).\n\nThe model is still in active development and has not yet been added to the official Julia package registry. To try it out, manually download the repository:\n\ngit clone git@github.com:hgpeterson/nuPGCM.git\ncd nuPGCM\njulia --project\n\nTo install the required dependencies, type ] to start the Pkg REPL and type\n\n(nuPGCM) pkg> instantiate\n\nTo run the example, you can backspace out of the Pkg REPL and run \n\njulia> include(\"examples/run.jl\")","category":"section"}]
}
