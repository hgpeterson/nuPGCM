<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Mixing in a bowl · νPGCM</title><meta name="title" content="Mixing in a bowl · νPGCM"/><meta property="og:title" content="Mixing in a bowl · νPGCM"/><meta property="twitter:title" content="Mixing in a bowl · νPGCM"/><meta name="description" content="Documentation for νPGCM."/><meta property="og:description" content="Documentation for νPGCM."/><meta property="twitter:description" content="Documentation for νPGCM."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">νPGCM</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Overview</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Model Formulation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../model_formulation/pg_equations/">The PG Equations</a></li><li><a class="tocitem" href="../../model_formulation/nondimensionalization/">Nondimensionalization</a></li><li><a class="tocitem" href="../../model_formulation/numerical_approach/">Numerical Approach</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked/><label class="tocitem" for="menuitem-3"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>Mixing in a bowl</a><ul class="internal"><li><a class="tocitem" href="#Setting-Parameters-and-Forcings"><span>Setting <code>Parameters</code> and <code>Forcings</code></span></a></li><li><a class="tocitem" href="#Loading-a-Mesh"><span>Loading a <code>Mesh</code></span></a></li><li class="toplevel"><a class="tocitem" href="#Define-Spaces"><span>Define <code>Spaces</code></span></a></li><li class="toplevel"><a class="tocitem" href="#Build-linear-systems"><span>Build linear systems</span></a></li><li class="toplevel"><a class="tocitem" href="#Construct-Model"><span>Construct <code>Model</code></span></a></li><li class="toplevel"><a class="tocitem" href="#run!"><span><code>run!</code></span></a></li></ul></li></ul></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Mixing in a bowl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Mixing in a bowl</a></li></ul></nav><div class="docs-right"><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Mixing-driven-circulation-in-a-bowl-shaped-basin"><a class="docs-heading-anchor" href="#Mixing-driven-circulation-in-a-bowl-shaped-basin">Mixing-driven circulation in a bowl-shaped basin</a><a id="Mixing-driven-circulation-in-a-bowl-shaped-basin-1"></a><a class="docs-heading-anchor-permalink" href="#Mixing-driven-circulation-in-a-bowl-shaped-basin" title="Permalink"></a></h1><p>This example illustrates the basic usage of the <span>$\nu$</span>PGCM by simulating a mixing-driven circulation in a bowl-shaped basin. The typical workflow is:</p><ul><li>Set your <code>Parameters</code> and <code>Forcings</code>,</li><li>Load a <code>Mesh</code>,</li><li>Define the finite element <code>Spaces</code>, including all Dirichlet boundary conditions,</li><li>Build the linear systems for the inversion and evolution equations,</li><li>Construct a <code>Model</code>, and</li><li><code>run!</code></li></ul><p>We will start by importing packages and setting the output directory for snapshot files.</p><pre><code class="language-julia hljs">using nuPGCM
using Printf

set_out_dir!(joinpath(@__DIR__, &quot;&quot;))</code></pre><pre><code class="nohighlight hljs">&quot;/home/runner/work/nuPGCM/nuPGCM/docs/src/literated//data&quot;</code></pre><p>You can choose to run the model on either a <code>CPU()</code> or <code>GPU()</code>. When you run on the CPU, the model will try to factorize matrices if they are small enough. On the GPU (or for large problems on the CPU), the model uses iterative solvers. For simplicity here, let&#39;s just use a CPU.</p><pre><code class="language-julia hljs">arch = CPU()</code></pre><pre><code class="nohighlight hljs">nuPGCM.CPU()</code></pre><h2 id="Setting-Parameters-and-Forcings"><a class="docs-heading-anchor" href="#Setting-Parameters-and-Forcings">Setting <code>Parameters</code> and <code>Forcings</code></a><a id="Setting-Parameters-and-Forcings-1"></a><a class="docs-heading-anchor-permalink" href="#Setting-Parameters-and-Forcings" title="Permalink"></a></h2><p>Now we will define our parameters. See the <strong>Model Formulation</strong> docs for more details. Our bowl-shaped basin has a simple depth function of <span>$H(x, y) = \alpha (1 - x^2 - y^2)$</span>.</p><pre><code class="language-julia hljs">ε = 2e-1   # Ekman number
α = 1/2    # aspect ratio
μϱ = 1     # Prandtl times Burger number
N² = 1/α   # background stratification (if you want `b` to be a perturbation from N²z)
Δt = 1e-3  # time step
f₀ = 1.0
β = 0.5
f(x) = f₀ + β*x[2]  # Coriolis parameter
H(x) = α*(1 - x[1]^2 - x[2]^2)  # bathymetry
params = Parameters(ε, α, μϱ, N², Δt, f, H)</code></pre><pre><code class="nohighlight hljs">nuPGCM.Parameters{Float64}
├── ε  = 2.0e-01
├── α  = 5.0e-01
├── μϱ = 1.0e+00
├── N² = 2.0e+00
├── Δt = 1.0e-03
├── f: f
└── H: H</code></pre><p>Next, we define the forcings. For this simple example, we&#39;ll be applying bottom-enhanced mixing and no wind stress.</p><pre><code class="language-julia hljs">ν = 1  # viscosity (can be a function of x)
κₕ(x) = 1e-2 + exp(-(x[3] + H(x))/(0.1*α)) # horizontal diffusivity
κᵥ(x) = 1e-2 + exp(-(x[3] + H(x))/(0.1*α)) # vertical diffusivity
τˣ(x) = 0  # zonal wind stress
τʸ(x) = 0  # meridional wind stress</code></pre><pre><code class="nohighlight hljs">τʸ (generic function with 1 method)</code></pre><p>You can choose whether the surface buoyancy forcing is a flux boundary condition (with <code>SurfaceFluxBC</code>) or a dirichlet boundary condition (with <code>SurfaceDirichletBC</code>). Here we&#39;ll just set <code>b = 0</code> at the surface.</p><pre><code class="language-julia hljs">b_surface(x) = 0  # surface buoyancy boundary condition
b_surface_bc = SurfaceDirichletBC(b_surface)
# flux syntax:
# b_flux_surface(x) = 0
# b_surface_bc = SurfaceFluxBC(b_flux_surface)

forcings = Forcings(ν, κₕ, κᵥ, τˣ, τʸ, b_surface_bc)</code></pre><pre><code class="nohighlight hljs">nuPGCM.Forcings:
├── ν: 1
├── κₕ: κₕ
├── κᵥ: κᵥ
├── τˣ: τˣ
├── τʸ: τʸ
├── b_surface_bc: nuPGCM.SurfaceDirichletBC
├── conv_param: off
└── eddy_param: off</code></pre><p>Notice that <code>forcings.conv_param</code> and <code>forcings.eddy_param</code> are by default set to <code>off</code>. These (somewhat experimental) new features can be defined like so:</p><pre><code class="language-julia hljs">conv_param = ConvectionParameterization(κᶜ=1e3, N²min=1e-3)
eddy_param = EddyParameterization(f=f, N²min=1e-2)
Forcings(ν, κₕ, κᵥ, τˣ, τʸ, b_surface_bc; conv_param, eddy_param)</code></pre><pre><code class="nohighlight hljs">nuPGCM.Forcings:
├── ν: 1
├── κₕ: κₕ
├── κᵥ: κᵥ
├── τˣ: τˣ
├── τʸ: τʸ
├── b_surface_bc: nuPGCM.SurfaceDirichletBC
├── conv_param: nuPGCM.ConvectionParameterization
└── eddy_param: nuPGCM.EddyParameterization</code></pre><p>But we&#39;ll leave them off here.</p><h2 id="Loading-a-Mesh"><a class="docs-heading-anchor" href="#Loading-a-Mesh">Loading a <code>Mesh</code></a><a id="Loading-a-Mesh-1"></a><a class="docs-heading-anchor-permalink" href="#Loading-a-Mesh" title="Permalink"></a></h2><p>Now we load our mesh. For some examples of how to generate a mesh with <a href="https://gmsh.info/">Gmsh</a>, see <a href="https://github.com/hgpeterson/nuPGCM/blob/main/meshes/mesh_bowl2D.jl"><code>mesh_bowl2D.jl</code></a>, <a href="https://github.com/hgpeterson/nuPGCM/blob/main/meshes/mesh_bowl3D.jl"><code>mesh_bowl3D.jl</code></a>, and others in the <code>meshes/</code> directory of the repository.</p><pre><code class="language-julia hljs">h = 8e-2
dim = 3
mesh_file = joinpath(@__DIR__, @sprintf(&quot;../../../meshes/bowl%dD_%e_%e.msh&quot;, dim, h, α))  # for Literate.jl
# mesh_file = joinpath(@__DIR__, @sprintf(&quot;../meshes/bowl%dD_%e_%e.msh&quot;, dim, h, α))  # for running from `examples/`
mesh = Mesh(mesh_file)</code></pre><pre><code class="nohighlight hljs">nuPGCM.Mesh:
├── model: UnstructuredDiscreteModel()
├── Ω: BodyFittedTriangulation()
├── dΩ: GenericMeasure()
├── Γ: BoundaryTriangulation()
└── dΓ: GenericMeasure()</code></pre><div class="admonition is-info" id="Note-af05054d9ee8034"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-af05054d9ee8034" title="Permalink"></a></header><div class="admonition-body"><p>You may have noticed that the <code>Mesh</code> fields are <a href="https://github.com/gridap/Gridap.jl"><code>Gridap</code></a> types. Under the hood, <code>nuPGCM</code> uses <code>Gridap</code> to compute all the finite element integrals. When we define the <code>Model</code> later, the <code>State</code> will contain <code>Gridap</code> <code>FEFunction</code>s.</p></div></div><h1 id="Define-Spaces"><a class="docs-heading-anchor" href="#Define-Spaces">Define <code>Spaces</code></a><a id="Define-Spaces-1"></a><a class="docs-heading-anchor-permalink" href="#Define-Spaces" title="Permalink"></a></h1><p>As described on the <a href="../../model_formulation/numerical_approach/">Numerical Approach</a> page, the <span>$\nu$</span>PGCM uses finite elements under the hood to solve the PG equations. Now that we have an unstructured mesh set up, we just need to define our Dirichlet boundary conditions to  be able to set up our finite element spaces.</p><p>In Gmsh, one can assign labels to parts of the mesh by defining &quot;physical groups.&quot; For the mesh we&#39;re using here, there are three physical groups defined: the <code>&quot;bottom&quot;</code>, <code>&quot;coastline&quot;</code>, and <code>&quot;surface&quot;</code>. To tell the <span>$\nu$</span>PGCM where to apply Dirichlet boundary conditions, we define tags and values for <span>$\vec{u} = (u, v, w)$</span> and <span>$b$</span> using these labels.</p><pre><code class="language-julia hljs">u_diri_tags = [&quot;bottom&quot;, &quot;coastline&quot;, &quot;surface&quot;]
u_diri_vals = [(0, 0, 0), (0, 0, 0), (0, 0, 0)]
u_diri_masks = [(true, true, true), (true, true, true), (false, false, true)]
b_diri_tags = [&quot;coastline&quot;, &quot;surface&quot;]
b_diri_vals = [b_surface, b_surface]
# b_diri_tags = []  # use this if b_surface_bc is a SurfaceFluxBC
# b_diri_vals = []  # use this if b_surface_bc is a SurfaceFluxBC
spaces = Spaces(mesh; u_diri_tags, u_diri_vals, u_diri_masks, b_diri_tags, b_diri_vals)</code></pre><pre><code class="nohighlight hljs">nuPGCM.Spaces:
├── X_trial: Gridap.MultiField.MultiFieldFESpace{Gridap.MultiField.ConsecutiveMultiFieldStyle, Gridap.FESpaces.UnConstrained, Vector{Float64}}
├── X_test: Gridap.MultiField.MultiFieldFESpace{Gridap.MultiField.ConsecutiveMultiFieldStyle, Gridap.FESpaces.UnConstrained, Vector{Float64}}
├── B_trial: Gridap.FESpaces.TrialFESpace{Gridap.FESpaces.UnconstrainedFESpace{Vector{Float64}, Gridap.FESpaces.CellConformity{Vector{Int8}}}}
├── B_test: Gridap.FESpaces.UnconstrainedFESpace{Vector{Float64}, Gridap.FESpaces.CellConformity{Vector{Int8}}}
└── b_diri: Gridap.FESpaces.SingleFieldFEFunction{Gridap.CellData.GenericCellField{Gridap.CellData.ReferenceDomain}}</code></pre><p>We have enforced the <span>$u = v = w = 0$</span> on the <code>&quot;bottom&quot;</code> and <code>&quot;coastline&quot;</code>, <span>$w = 0$</span> at the <code>&quot;surface&quot;</code>, and <span>$b = 0$</span> at the <code>&quot;surface&quot;</code> and on the <code>&quot;coastline&quot;</code>. All other boundaries are treated &quot;naturally,&quot; i.e., the flux across them is zero.</p><div class="admonition is-warning" id="Be-careful-about-defining-your-physical-groups!-a354d981b923564c"><header class="admonition-header">Be careful about defining your physical groups!<a class="admonition-anchor" href="#Be-careful-about-defining-your-physical-groups!-a354d981b923564c" title="Permalink"></a></header><div class="admonition-body"><p>Make sure that when you create your <code>.msh</code> files you carefully check that your physical groupd definitions properly account for every entity in the mesh! For some examples, see the <a href="https://github.com/hgpeterson/nuPGCM/tree/main/meshes"><code>meshes/</code></a> folder in the <code>nuPGCM</code> repository.</p></div></div><p>Our <code>mesh</code> and <code>spaces</code> are then passed to the <code>FEData</code> constructor, which keeps track of all the finite element data needed to compute build our linear systems.</p><pre><code class="language-julia hljs">fe_data = FEData(mesh, spaces)</code></pre><pre><code class="nohighlight hljs">nuPGCM.FEData:
├── mesh: nuPGCM.Mesh
├── spaces: nuPGCM.Spaces
└── dofs: nuPGCM.DoFHandler{Vector{Int64}, Int64} with (nu=29353, np=2042, nb=11211) DOFs</code></pre><p>Behind the scenes, this created a <code>DoFHandler</code>, which you can use to see how many degrees of freedom the problem has.</p><pre><code class="language-julia hljs">fe_data.dofs</code></pre><pre><code class="nohighlight hljs">nuPGCM.DoFHandler{Vector{Int64}, Int64} with (nu=29353, np=2042, nb=11211) DOFs:
├── p_u and inv_p_u: 29353-element Vector{Int64}&#39;s
├── p_p and inv_p_p: 2042-element Vector{Int64}&#39;s
├── p_inversion and inv_p_inversion: 31395-element Vector{Int64}&#39;s
└── p_b and inv_p_b: 11211-element Vector{Int64}&#39;s</code></pre><h1 id="Build-linear-systems"><a class="docs-heading-anchor" href="#Build-linear-systems">Build linear systems</a><a id="Build-linear-systems-1"></a><a class="docs-heading-anchor-permalink" href="#Build-linear-systems" title="Permalink"></a></h1><p>We now have everything we need to build the linear systems that represent the discretized PG equations on this mesh. First, we build the inversion system alone, as it does not have a time-dependent piece:</p><pre><code class="language-julia hljs">inversion_toolkit = InversionToolkit(arch, fe_data, params, forcings; atol=1e-6, rtol=1e-6)</code></pre><pre><code class="nohighlight hljs">nuPGCM.InversionToolkit:
├── B: 31395×11211 SparseArrays.SparseMatrixCSC{Float64, Int64} with 670303 stored entries
├── b: 31395-element Vector{Float64}
└── solver: nuPGCM.IterativeSolverToolkit</code></pre><p>The <code>atol</code> and <code>rtol</code> kwargs are the absolute and relative tolerances, respectively, used when solving the system iteratively. Make them smaller if you want higher accuracy at the expense of more inversion iterations. Since we are on a CPU and our mesh is quite coarse in this example, however, the model will actually just do a direct solve, so these tolerances are unused.</p><p>At this point, we can already compute the flow field if we know what the buoyancy field is. To do this, just create a <code>Model</code> without an evolution piece, set the buoyancy field, and invert:</p><pre><code class="language-julia hljs">model = Model(arch, params, forcings, fe_data, inversion_toolkit)
set_b!(model, x -&gt; 0.1*exp(-(x[3] + H(x))/(0.1*α)))
invert!(model)
save_state(model, &quot;$out_dir/data/state.jld2&quot;)
save_vtk(model, ofile=&quot;$out_dir/data/state.vtu&quot;)</code></pre><pre><code class="nohighlight hljs">[ Info: Model state saved to &#39;/home/runner/work/nuPGCM/nuPGCM/docs/src/literated//data/state.jld2&#39;
[ Info: VTK state saved to &#39;/home/runner/work/nuPGCM/nuPGCM/docs/src/literated//data/state.vtu&#39;
</code></pre><p>Here we want to see how the flow and buoyancy evolve in time, however, so we need to build the evolution system.</p><pre><code class="language-julia hljs">evolution_toolkit = EvolutionToolkit(arch, fe_data, params, forcings)</code></pre><pre><code class="nohighlight hljs">nuPGCM.EvolutionToolkit:
├── arch: nuPGCM.CPU()
├── B_hdiff: 11211×11211 SparseArrays.SparseMatrixCSC{Float64, Int64} with 267151 stored entries
├── b_hdiff: 11211-element Vector{Float64}
├── B_vdiff: 11211×11211 SparseArrays.SparseMatrixCSC{Float64, Int64} with 267151 stored entries
├── b_vdiff: 11211-element Vector{Float64}
├── solver_adv: nuPGCM.IterativeSolverToolkit
├── solver_hdiff: nuPGCM.IterativeSolverToolkit
├── solver_vdiff: nuPGCM.IterativeSolverToolkit
└── order: 2</code></pre><h1 id="Construct-Model"><a class="docs-heading-anchor" href="#Construct-Model">Construct <code>Model</code></a><a id="Construct-Model-1"></a><a class="docs-heading-anchor-permalink" href="#Construct-Model" title="Permalink"></a></h1><p>Now we put everything together in the <code>Model</code> type.</p><pre><code class="language-julia hljs">model = Model(arch, params, forcings, fe_data, inversion_toolkit, evolution_toolkit)</code></pre><pre><code class="nohighlight hljs">nuPGCM.Model:
├── arch: nuPGCM.CPU()
├── params: nuPGCM.Parameters{Float64}
├── forcings: nuPGCM.Forcings
├── fe_data: nuPGCM.FEData
├── inversion: nuPGCM.InversionToolkit
├── evolution: nuPGCM.EvolutionToolkit
└── state: nuPGCM.State</code></pre><p>We can set the intial condition to be whatever we want with <code>set_b!(model, foo)</code> where <code>foo</code> is a function of <code>x</code>. By default, the buoyancy is always set to 0 initially. Since we set <code>N²</code> to <code>1/α</code>, this means that our buoyancy field starts out as <code>x[3]/α</code>―a constant stratification. If you had <code>N² = 0</code>, then you would need to do <code>set_b!(model, x -&gt; x[3]/α)</code> to get the same effect. The benefit of having a nonzero background startification is that the inversion tends to be more accurate for smaller variations in buoyancy.</p><p>To start with, let&#39;s sync up the flow with whatever initial condition we chose and save a <code>.vtu</code> file.</p><pre><code class="language-julia hljs">invert!(model) # sync flow with initial condition
save_vtk(model, ofile=@sprintf(&quot;%s/data/state_%016d.vtu&quot;, out_dir, 0))</code></pre><pre><code class="nohighlight hljs">[ Info: VTK state saved to &#39;/home/runner/work/nuPGCM/nuPGCM/docs/src/literated//data/state_0000000000000000.vtu&#39;
</code></pre><h1 id="run!"><a class="docs-heading-anchor" href="#run!"><code>run!</code></a><a id="run!-1"></a><a class="docs-heading-anchor-permalink" href="#run!" title="Permalink"></a></h1><p>Finally, it&#39;s time to run the model! <code>run!</code> just needs to know how many steps to take <code>n_steps</code>, how often to make save files <code>n_save</code> (default <code>Inf</code>), and how often to make plots <code>n_plot</code> (default <code>Inf</code>). If you want to turn advection off and only diffuse buoyancy, set <code>advection=false</code>. If you are starting from a save file, you can also set <code>i_step</code> to something other than <code>1</code>.</p><pre><code class="language-julia hljs">T = 0.1*μϱ/ε^2  # simulation time
n_steps = Int(round(T / Δt))
n_save = n_steps ÷ 100
run!(model; n_steps, n_save)</code></pre><pre><code class="nohighlight hljs">nuPGCM.Model:
├── arch: nuPGCM.CPU()
├── params: nuPGCM.Parameters{Float64}
├── forcings: nuPGCM.Forcings
├── fe_data: nuPGCM.FEData
├── inversion: nuPGCM.InversionToolkit
├── evolution: nuPGCM.EvolutionToolkit
└── state: nuPGCM.State</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../model_formulation/numerical_approach/">« Numerical Approach</a><a class="docs-footer-nextpage" href="../../references/">References »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Friday 16 January 2026 01:05">Friday 16 January 2026</span>. Using Julia version 1.12.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
